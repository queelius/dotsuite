{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Dot Notation Universe This is the central documentation for the dot ecosystem, a suite of tools for data manipulation.","title":"Welcome to the Dot Notation Universe"},{"location":"#welcome-to-the-dot-notation-universe","text":"This is the central documentation for the dot ecosystem, a suite of tools for data manipulation.","title":"Welcome to the Dot Notation Universe"},{"location":"dot-formalism/","text":"The dot Ecosystem \u2014 A Formal Blueprint Premise. Manipulating semi-structured data is easiest when every operation answers exactly one question and composes cleanly with every other operation. Goal. Provide a minimal yet complete algebra for JSON-like documents and their collections, with clear pedagogical on-ramps. Method. Factor the problem space into three orthogonal pillars (Depth \u2248 Addressing, Truth \u2248 Logic, Shape \u2248 Transformation) and lift them from single documents to collections. 1\u2003The Three Pillars Pillar Core Question Domain Codomain Primitive Depth \u201c Where is the data?\u201d Document Path \u21a6 \ud835\udc49* dotget Truth \u201c Is this assertion true here?\u201d Document \ud835\udd39 dotexists Shape \u201c How should the data be re-shaped?\u201d Document Document dotpluck Notation. A JSON document is an element of $\\mathcal D$. A path is a finite sequence of selectors; evaluation yields either a single value or a multiset $V^{*}$ (to accommodate wildcards). Boolean results live in $\\mathbb B={\\bot,\\top}$. 1.1\u2003Depth \u2014 Addressing Algebra Layer Operator Semantic Type Observations entry dotget $\\mathcal D \\times \\text{Path}_{\\text{exact}}\\to V\\cup{\\emptyset}$ Total if we treat \u201cmissing\u201d as $\\emptyset$. pattern dotstar $\\mathcal D \\times \\text{Path}_{ } \\to V^{ }$ Wildcards induce Kleene-star expansion. workhorse dotselect $\\mathcal D \\times \\text{Path}_{\\text{expr}} \\to V^{*}$ Admits slices, filters \u2194 regular-path queries. engine dotpath Free algebra on selectors; Turing-complete by user-defined reducers. Formally each operator is a morphism in the Kleisli category of the powerset monad, ensuring compositionality: dotstar \u2218 dotselect \u2192 still a set of values. 1.2\u2003Truth \u2014 Predicate Calculus Layer Operator Type Law structure dotexists $\\mathcal D \\times P \\to \ud835\udd39$ exists(p) \u2261 count(dotstar(p)) > 0 . content dotequals $\\mathcal D \\times (P,V) \\to \ud835\udd39$ Reflexive, symmetric only on singleton paths. quantifiers dotany / dotall $\\mathcal D \\times (P, \u03c6) \\to \ud835\udd39$ Lift predicate $\u03c6$ point-wise then aggregate with \u2228 / \u2227. engine dotquery $\\mathcal D \\times \\mathcal L_{BOOL}(\u03c6_i) \\to \ud835\udd39$ $\\mathcal L_{BOOL}$ is propositional logic; distributive laws preserve short-circuit semantics. Boolean algebra closure. Predicates form a Boolean algebra under \u2227, \u2228, \u00ac that is homomorphic to set algebra on result subsets (intersection, union, complement). 1.3\u2003Shape \u2014 Endofunctors on $\\mathcal D$ Layer Operator Type Category-theoretic view extract dotpluck $\\mathcal D \\times P \\to V^{*}$ Not a transform; a projection functor to Sets. surgical dotmod $\\mathcal D \\times \u03b4 \\to \\mathcal D$ \u03b4 = {insert, update, delete}. Lens with put-get law. compositional dotpipe $\\mathcal D \\times F^{*} \\to \\mathcal D$ Kleisli composition of pure functions $F: \\mathcal D\u2192\\mathcal D$. transactional dotbatch $\\mathcal D^{ } \\times \u0394^{ } \\to \\mathcal D^{*}$ Monoid action; supports ACID if \u0394 is sequence-serialisable. 2\u2003Lifting to Collections Let a collection be a finite multiset $C \\subseteq \\mathcal D$. Operations lift via: $$ \\operatorname{map} : (\\mathcal D \\to X) \\to (C \\to X^{*}) \\qquad \\operatorname{filter} : (\\mathcal D \\to \ud835\udd39) \\to (C \\to C) $$ 2.1\u2003Boolean Wing (Filtering) Operator Definition Note dothas $C, P \\mapsto {d\u2208C \\mid \\text{dotexists}(d,P)}$ Primitive filter. dotfind $C, \u03c6 \\mapsto {d\u2208C \\mid \u03c6(d)}$ \u03c6 any Truth-pillar predicate. dotfilter Higher-order: accepts combinators (AND/OR/NOT). Closure under Boolean algebra proven by homomorphism. 2.2\u2003Transforming Wing (Mapping & Relating) Operator Lifted From Semantics dotmod , dotpipe , dotbatch , dotpluck Shape pillar Point-wise map; distributive over union. dotrelate new Binary relation $C_1 \\Join C_2 \\to C_{12}$; isomorphic to relational algebra (\u03c3, \u03c0, \u22c8, \u222a, \u2212). Key guarantee. Every collection operator is a monoid homomorphism w.r.t. multiset union, enabling parallelisation and streaming. 3\u2003Pedagogical Gradient Hello-World phase. dotget , dotexists , dotpluck \u2014 O(1) mental load. Pattern phase. Add dotstar , dotequals , dotmod . Power-user phase. dotselect , dotany/all , dotpipe . Expert / DSL author. dotpath , dotquery , dotbatch , dotrelate . Each stage is conservative : every new construct can be desugared into earlier ones plus a small kernel, preserving learnability. 4\u2003Design Invariants Purity & Immutability. Functions are referentially transparent; concurrency is trivial. Totality by Convention. Missing paths yield $\\emptyset$ rather than exceptions, pushing error handling into the type. Compositionality. Operators form algebras (Boolean, monoidal, Kleisli) guaranteeing that compose \u21d2 reason locally . Orthogonality. No operator belongs to more than one pillar; cross-cutting concerns are expresses as functor lifts, not ad-hoc features. Extensibility. Users can register new selector primitives or predicates; completion is measured against algebraic closure, not feature lists. 5\u2003Big-Picture Fit dot \u2019s Depth\u2013Truth\u2013Shape triad mirrors the CRUD partition (Read, Validate, Update). The collection lift embeds seamlessly into stream processors (e.g., UNIX pipes, Apache Beam) because all lifted ops are monoid homomorphisms. Advanced users can harvest category-theoretic intuition: paths are optics , predicates are subobjects , transforms are endofunctors . The architecture matches database theory: single-document logic \u2248 tuple calculus; dotrelate \u2248 relational algebra; streaming lift \u2248 data-parallel query plans. 6\u2003Next Questions (Skeptical Checklist) Can every JSONPath feature be expressed in dotpath without semantic leaks? Are dotbatch rollbacks composable with streaming sinks? Which algebraic laws break under heterogeneous array mixes, and do we care? How do we reconcile user-defined side-effectful functions with purity guarantees? Can the type system (e.g., gradual typing) enforce pillar boundaries statically? TL;DR dot is not a toolbox; it is a small, law-governed algebra for interrogating and reshaping data. Three orthogonal pillars give you location, truth, and transformation; functorial lifting scales them to streams. Everything else is just syntax sugar. let's think very carefully about how to improve our documents with this formalism. we can also read from proposal-collections-pillar.md for ideas.","title":"The dot Ecosystem \u2014 A Formal Blueprint"},{"location":"dot-formalism/#the-dot-ecosystem-a-formal-blueprint","text":"Premise. Manipulating semi-structured data is easiest when every operation answers exactly one question and composes cleanly with every other operation. Goal. Provide a minimal yet complete algebra for JSON-like documents and their collections, with clear pedagogical on-ramps. Method. Factor the problem space into three orthogonal pillars (Depth \u2248 Addressing, Truth \u2248 Logic, Shape \u2248 Transformation) and lift them from single documents to collections.","title":"The dot Ecosystem \u2014 A Formal Blueprint"},{"location":"dot-formalism/#1-the-three-pillars","text":"Pillar Core Question Domain Codomain Primitive Depth \u201c Where is the data?\u201d Document Path \u21a6 \ud835\udc49* dotget Truth \u201c Is this assertion true here?\u201d Document \ud835\udd39 dotexists Shape \u201c How should the data be re-shaped?\u201d Document Document dotpluck Notation. A JSON document is an element of $\\mathcal D$. A path is a finite sequence of selectors; evaluation yields either a single value or a multiset $V^{*}$ (to accommodate wildcards). Boolean results live in $\\mathbb B={\\bot,\\top}$.","title":"1 The Three Pillars"},{"location":"dot-formalism/#11-depth-addressing-algebra","text":"Layer Operator Semantic Type Observations entry dotget $\\mathcal D \\times \\text{Path}_{\\text{exact}}\\to V\\cup{\\emptyset}$ Total if we treat \u201cmissing\u201d as $\\emptyset$. pattern dotstar $\\mathcal D \\times \\text{Path}_{ } \\to V^{ }$ Wildcards induce Kleene-star expansion. workhorse dotselect $\\mathcal D \\times \\text{Path}_{\\text{expr}} \\to V^{*}$ Admits slices, filters \u2194 regular-path queries. engine dotpath Free algebra on selectors; Turing-complete by user-defined reducers. Formally each operator is a morphism in the Kleisli category of the powerset monad, ensuring compositionality: dotstar \u2218 dotselect \u2192 still a set of values.","title":"1.1 Depth \u2014 Addressing Algebra"},{"location":"dot-formalism/#12-truth-predicate-calculus","text":"Layer Operator Type Law structure dotexists $\\mathcal D \\times P \\to \ud835\udd39$ exists(p) \u2261 count(dotstar(p)) > 0 . content dotequals $\\mathcal D \\times (P,V) \\to \ud835\udd39$ Reflexive, symmetric only on singleton paths. quantifiers dotany / dotall $\\mathcal D \\times (P, \u03c6) \\to \ud835\udd39$ Lift predicate $\u03c6$ point-wise then aggregate with \u2228 / \u2227. engine dotquery $\\mathcal D \\times \\mathcal L_{BOOL}(\u03c6_i) \\to \ud835\udd39$ $\\mathcal L_{BOOL}$ is propositional logic; distributive laws preserve short-circuit semantics. Boolean algebra closure. Predicates form a Boolean algebra under \u2227, \u2228, \u00ac that is homomorphic to set algebra on result subsets (intersection, union, complement).","title":"1.2 Truth \u2014 Predicate Calculus"},{"location":"dot-formalism/#13-shape-endofunctors-on-mathcal-d","text":"Layer Operator Type Category-theoretic view extract dotpluck $\\mathcal D \\times P \\to V^{*}$ Not a transform; a projection functor to Sets. surgical dotmod $\\mathcal D \\times \u03b4 \\to \\mathcal D$ \u03b4 = {insert, update, delete}. Lens with put-get law. compositional dotpipe $\\mathcal D \\times F^{*} \\to \\mathcal D$ Kleisli composition of pure functions $F: \\mathcal D\u2192\\mathcal D$. transactional dotbatch $\\mathcal D^{ } \\times \u0394^{ } \\to \\mathcal D^{*}$ Monoid action; supports ACID if \u0394 is sequence-serialisable.","title":"1.3 Shape \u2014 Endofunctors on $\\mathcal D$"},{"location":"dot-formalism/#2-lifting-to-collections","text":"Let a collection be a finite multiset $C \\subseteq \\mathcal D$. Operations lift via: $$ \\operatorname{map} : (\\mathcal D \\to X) \\to (C \\to X^{*}) \\qquad \\operatorname{filter} : (\\mathcal D \\to \ud835\udd39) \\to (C \\to C) $$","title":"2 Lifting to Collections"},{"location":"dot-formalism/#21-boolean-wing-filtering","text":"Operator Definition Note dothas $C, P \\mapsto {d\u2208C \\mid \\text{dotexists}(d,P)}$ Primitive filter. dotfind $C, \u03c6 \\mapsto {d\u2208C \\mid \u03c6(d)}$ \u03c6 any Truth-pillar predicate. dotfilter Higher-order: accepts combinators (AND/OR/NOT). Closure under Boolean algebra proven by homomorphism.","title":"2.1 Boolean Wing (Filtering)"},{"location":"dot-formalism/#22-transforming-wing-mapping-relating","text":"Operator Lifted From Semantics dotmod , dotpipe , dotbatch , dotpluck Shape pillar Point-wise map; distributive over union. dotrelate new Binary relation $C_1 \\Join C_2 \\to C_{12}$; isomorphic to relational algebra (\u03c3, \u03c0, \u22c8, \u222a, \u2212). Key guarantee. Every collection operator is a monoid homomorphism w.r.t. multiset union, enabling parallelisation and streaming.","title":"2.2 Transforming Wing (Mapping &amp; Relating)"},{"location":"dot-formalism/#3-pedagogical-gradient","text":"Hello-World phase. dotget , dotexists , dotpluck \u2014 O(1) mental load. Pattern phase. Add dotstar , dotequals , dotmod . Power-user phase. dotselect , dotany/all , dotpipe . Expert / DSL author. dotpath , dotquery , dotbatch , dotrelate . Each stage is conservative : every new construct can be desugared into earlier ones plus a small kernel, preserving learnability.","title":"3 Pedagogical Gradient"},{"location":"dot-formalism/#4-design-invariants","text":"Purity & Immutability. Functions are referentially transparent; concurrency is trivial. Totality by Convention. Missing paths yield $\\emptyset$ rather than exceptions, pushing error handling into the type. Compositionality. Operators form algebras (Boolean, monoidal, Kleisli) guaranteeing that compose \u21d2 reason locally . Orthogonality. No operator belongs to more than one pillar; cross-cutting concerns are expresses as functor lifts, not ad-hoc features. Extensibility. Users can register new selector primitives or predicates; completion is measured against algebraic closure, not feature lists.","title":"4 Design Invariants"},{"location":"dot-formalism/#5-big-picture-fit","text":"dot \u2019s Depth\u2013Truth\u2013Shape triad mirrors the CRUD partition (Read, Validate, Update). The collection lift embeds seamlessly into stream processors (e.g., UNIX pipes, Apache Beam) because all lifted ops are monoid homomorphisms. Advanced users can harvest category-theoretic intuition: paths are optics , predicates are subobjects , transforms are endofunctors . The architecture matches database theory: single-document logic \u2248 tuple calculus; dotrelate \u2248 relational algebra; streaming lift \u2248 data-parallel query plans.","title":"5 Big-Picture Fit"},{"location":"dot-formalism/#6-next-questions-skeptical-checklist","text":"Can every JSONPath feature be expressed in dotpath without semantic leaks? Are dotbatch rollbacks composable with streaming sinks? Which algebraic laws break under heterogeneous array mixes, and do we care? How do we reconcile user-defined side-effectful functions with purity guarantees? Can the type system (e.g., gradual typing) enforce pillar boundaries statically?","title":"6 Next Questions (Skeptical Checklist)"},{"location":"dot-formalism/#tldr","text":"dot is not a toolbox; it is a small, law-governed algebra for interrogating and reshaping data. Three orthogonal pillars give you location, truth, and transformation; functorial lifting scales them to streams. Everything else is just syntax sugar. let's think very carefully about how to improve our documents with this formalism. we can also read from proposal-collections-pillar.md for ideas.","title":"TL;DR"},{"location":"dot-notation-universe/","text":"The Dot Notation Universe: A Journey in API Design It always starts with a simple problem. You have a nested dictionary or a JSON payload, and you need to get a value buried deep inside. You write data['user']['contacts'][0]['email'] and you pray that no key or index is missing along the way, lest your program crash. This leads to brittle, defensive code. The first, obvious solution is a helper function. This is where our story begins. What started as a single, humble function, dotget , evolved through a series of questions and insights into a complete, coherent, and powerful ecosystem for manipulating data structures. This is the story of that evolution\u2014a journey in API design guided by the principles of purity, pedagogy, and the principle of least power. Part I: The Single Document - The Three Pillars of Intelligence Mastering operations inside a single, complex document is the foundation of the entire ecosystem. We discovered that this \"per-document intelligence\" isn't a single path, but rests on three distinct pillars, each answering a different fundamental question. Pillar 1: The Addressing Layer (Retrieval) This is the bedrock. It answers the question: \"WHAT is the value at a given location?\" Its tools are designed purely for finding and returning data. dotget (Exact Addressing): The starting point. It retrieves a single value from a precise, known path (e.g., \"users.0.name\" ). dotstar (Pattern Addressing): Introduces the * wildcard to retrieve multiple values from a structural pattern (e.g., \"users.*.name\" ). dotquery (Conditional Addressing): The master addressing engine. It understands a complete path language, including conditional predicates ( [key=value] ) and descendant wildcards ( ** ), to find and retrieve data from the most complex locations. Pillar 2: The Logic Layer (Assertion) Once we can find data, the next question is not about the data's value, but its veracity. This pillar answers the question: \"IS a statement about this document true?\" Its output is always a boolean. dotexists (Simple Existence): The simplest logical test. It takes a dotget -style exact path and returns True if it resolves to a value. dotany / dotall (Quantifiers): This is the necessary next step for handling paths that return multiple values. It forces the user to be explicit about their intent. dotany checks if at least one returned value meets a condition, while dotall checks if all of them do. dotlogic (Compositional Logic): The final stage. This is a full predicate engine that can compose the results of simpler checks using AND , OR , NOT . It can evaluate complex, self-referential assertions, such as checking if two different lists of values within the document have any intersection. Pillar 3: The Action Layer (Manipulation) This pillar answers the question: \"HOW should this document be changed?\" It uses the Addressing Layer to find where to act. It is built on the principle of immutability\u2014always returning a modified copy. The \"Write\" Branch ( dotmod , dotbatch ): This branch is for direct mutation. dotmod provides the verbs for single changes ( set_ , delete_ ), while dotbatch provides the transactional capability to apply a sequence of changes atomically. Its output is the same document, modified ( Doc -> Doc ). The \"Transform\" Branch ( dotmap ): This branch is for reshaping data. It takes a document and derives a new structure from it, such as a simplified \"view model\" for a UI. Its output can be of any shape ( Doc -> Any ). Part II: Collections of Documents - A World of \"Breadth\" With a complete toolkit for single documents, we can now operate on collections, often represented as a stream of documents like in a JSONL file. This \"Breadth\" axis has two main pillars that use the per-document tools as their internal machinery. dotset : A Boolean Algebra for Collections dotset filters a collection. It answers the question: \"Which documents in this collection match a set of logical rules?\" Its power comes from using the Logic Pillar as its decision engine for each document. A lazy, compositional QuerySet API allows for building complex queries efficiently. # Find all logs that are either a critical server error OR # a database call that was too slow, but EXCLUDING any from a known-buggy service. logs = QuerySet(log_collection) # This query is translated into a dotlogic AST and applied to each document. results = logs.filter( Q(level=\"error\", source=\"server\") | Q(source=\"db\", latency_ms__gt=500) ).exclude( service_name=\"buggy-service-alpha\" ) dotrelate : A Relational Algebra for Collections While dotset filters a collection, dotrelate transforms and combines multiple collections. It's the conceptual parallel to dotmap , but for datasets. It answers: \"How can these distinct collections be joined to create new, enriched data?\" The core operation is the join , which combines documents from two collections based on a shared key. # users = [{\"user_id\": 1, \"name\": \"Alice\"}, ...] # orders = [{\"order_id\": 101, \"user_id\": 2, \"item\": \"Book\"}, ...] # Enrich each order with the name of the user who placed it. enriched_orders = dotrelate.join(left=orders, right=users, on=\"user_id\") # -> [{\"order_id\": 101, ..., \"name\": \"Bob\"}, ...] The Big Picture: A Unified Architecture This journey reveals a coherent universe of tools, underpinned by a dual API (programmatic for developers, declarative JSON/string for users) and a philosophy of clean, single-purpose components. graph TD subgraph The_Dot_Universe [\"The Dot Notation Universe\"] subgraph Single_Doc [\"Part I: Per-Document Intelligence ('Depth')\"] direction TB subgraph Addressing_Layer [\"Pillar 1: Addressing (Retrieval)\"] dotget(\"dotget\") --> dotstar(\"dotstar\") --> dotquery(\"dotquery\") end subgraph Logic_Layer [\"Pillar 2: Logic (Assertion)\"] dotexists(\"dotexists\") --> dotanyall(\"dotany/dotall\") --> dotlogic(\"dotlogic\") end subgraph Action_Layer [\"Pillar 3: Action (Manipulation)\"] direction LR write_branch[\"Write Branch<br>(dotmod, dotbatch)\"] transform_branch[\"Transform Branch<br>(dotmap)\"] end end subgraph Collection_Ops [\"Part II: Collection Operations ('Breadth')\"] direction TB subgraph Filter_Branch [\"Filter / Boolean Algebra\"] dotset(\"dotset\") end subgraph Relate_Branch [\"Relate / Relational Algebra\"] dotrelate(\"dotrelate\") end end Addressing_Layer -- \"Provides paths for\" --> Action_Layer Addressing_Layer -- \"Provides paths for\" --> Logic_Layer Logic_Layer -- \"Provides decision engine for\" --> Collection_Ops Action_Layer -- \"(dotmap) provides primitives for\" --> Relate_Branch end","title":"The Dot Notation Universe: A Journey in API Design"},{"location":"dot-notation-universe/#the-dot-notation-universe-a-journey-in-api-design","text":"It always starts with a simple problem. You have a nested dictionary or a JSON payload, and you need to get a value buried deep inside. You write data['user']['contacts'][0]['email'] and you pray that no key or index is missing along the way, lest your program crash. This leads to brittle, defensive code. The first, obvious solution is a helper function. This is where our story begins. What started as a single, humble function, dotget , evolved through a series of questions and insights into a complete, coherent, and powerful ecosystem for manipulating data structures. This is the story of that evolution\u2014a journey in API design guided by the principles of purity, pedagogy, and the principle of least power.","title":"The Dot Notation Universe: A Journey in API Design"},{"location":"dot-notation-universe/#part-i-the-single-document-the-three-pillars-of-intelligence","text":"Mastering operations inside a single, complex document is the foundation of the entire ecosystem. We discovered that this \"per-document intelligence\" isn't a single path, but rests on three distinct pillars, each answering a different fundamental question.","title":"Part I: The Single Document - The Three Pillars of Intelligence"},{"location":"dot-notation-universe/#pillar-1-the-addressing-layer-retrieval","text":"This is the bedrock. It answers the question: \"WHAT is the value at a given location?\" Its tools are designed purely for finding and returning data. dotget (Exact Addressing): The starting point. It retrieves a single value from a precise, known path (e.g., \"users.0.name\" ). dotstar (Pattern Addressing): Introduces the * wildcard to retrieve multiple values from a structural pattern (e.g., \"users.*.name\" ). dotquery (Conditional Addressing): The master addressing engine. It understands a complete path language, including conditional predicates ( [key=value] ) and descendant wildcards ( ** ), to find and retrieve data from the most complex locations.","title":"Pillar 1: The Addressing Layer (Retrieval)"},{"location":"dot-notation-universe/#pillar-2-the-logic-layer-assertion","text":"Once we can find data, the next question is not about the data's value, but its veracity. This pillar answers the question: \"IS a statement about this document true?\" Its output is always a boolean. dotexists (Simple Existence): The simplest logical test. It takes a dotget -style exact path and returns True if it resolves to a value. dotany / dotall (Quantifiers): This is the necessary next step for handling paths that return multiple values. It forces the user to be explicit about their intent. dotany checks if at least one returned value meets a condition, while dotall checks if all of them do. dotlogic (Compositional Logic): The final stage. This is a full predicate engine that can compose the results of simpler checks using AND , OR , NOT . It can evaluate complex, self-referential assertions, such as checking if two different lists of values within the document have any intersection.","title":"Pillar 2: The Logic Layer (Assertion)"},{"location":"dot-notation-universe/#pillar-3-the-action-layer-manipulation","text":"This pillar answers the question: \"HOW should this document be changed?\" It uses the Addressing Layer to find where to act. It is built on the principle of immutability\u2014always returning a modified copy. The \"Write\" Branch ( dotmod , dotbatch ): This branch is for direct mutation. dotmod provides the verbs for single changes ( set_ , delete_ ), while dotbatch provides the transactional capability to apply a sequence of changes atomically. Its output is the same document, modified ( Doc -> Doc ). The \"Transform\" Branch ( dotmap ): This branch is for reshaping data. It takes a document and derives a new structure from it, such as a simplified \"view model\" for a UI. Its output can be of any shape ( Doc -> Any ).","title":"Pillar 3: The Action Layer (Manipulation)"},{"location":"dot-notation-universe/#part-ii-collections-of-documents-a-world-of-breadth","text":"With a complete toolkit for single documents, we can now operate on collections, often represented as a stream of documents like in a JSONL file. This \"Breadth\" axis has two main pillars that use the per-document tools as their internal machinery.","title":"Part II: Collections of Documents - A World of \"Breadth\""},{"location":"dot-notation-universe/#dotset-a-boolean-algebra-for-collections","text":"dotset filters a collection. It answers the question: \"Which documents in this collection match a set of logical rules?\" Its power comes from using the Logic Pillar as its decision engine for each document. A lazy, compositional QuerySet API allows for building complex queries efficiently. # Find all logs that are either a critical server error OR # a database call that was too slow, but EXCLUDING any from a known-buggy service. logs = QuerySet(log_collection) # This query is translated into a dotlogic AST and applied to each document. results = logs.filter( Q(level=\"error\", source=\"server\") | Q(source=\"db\", latency_ms__gt=500) ).exclude( service_name=\"buggy-service-alpha\" )","title":"dotset: A Boolean Algebra for Collections"},{"location":"dot-notation-universe/#dotrelate-a-relational-algebra-for-collections","text":"While dotset filters a collection, dotrelate transforms and combines multiple collections. It's the conceptual parallel to dotmap , but for datasets. It answers: \"How can these distinct collections be joined to create new, enriched data?\" The core operation is the join , which combines documents from two collections based on a shared key. # users = [{\"user_id\": 1, \"name\": \"Alice\"}, ...] # orders = [{\"order_id\": 101, \"user_id\": 2, \"item\": \"Book\"}, ...] # Enrich each order with the name of the user who placed it. enriched_orders = dotrelate.join(left=orders, right=users, on=\"user_id\") # -> [{\"order_id\": 101, ..., \"name\": \"Bob\"}, ...]","title":"dotrelate: A Relational Algebra for Collections"},{"location":"dot-notation-universe/#the-big-picture-a-unified-architecture","text":"This journey reveals a coherent universe of tools, underpinned by a dual API (programmatic for developers, declarative JSON/string for users) and a philosophy of clean, single-purpose components. graph TD subgraph The_Dot_Universe [\"The Dot Notation Universe\"] subgraph Single_Doc [\"Part I: Per-Document Intelligence ('Depth')\"] direction TB subgraph Addressing_Layer [\"Pillar 1: Addressing (Retrieval)\"] dotget(\"dotget\") --> dotstar(\"dotstar\") --> dotquery(\"dotquery\") end subgraph Logic_Layer [\"Pillar 2: Logic (Assertion)\"] dotexists(\"dotexists\") --> dotanyall(\"dotany/dotall\") --> dotlogic(\"dotlogic\") end subgraph Action_Layer [\"Pillar 3: Action (Manipulation)\"] direction LR write_branch[\"Write Branch<br>(dotmod, dotbatch)\"] transform_branch[\"Transform Branch<br>(dotmap)\"] end end subgraph Collection_Ops [\"Part II: Collection Operations ('Breadth')\"] direction TB subgraph Filter_Branch [\"Filter / Boolean Algebra\"] dotset(\"dotset\") end subgraph Relate_Branch [\"Relate / Relational Algebra\"] dotrelate(\"dotrelate\") end end Addressing_Layer -- \"Provides paths for\" --> Action_Layer Addressing_Layer -- \"Provides paths for\" --> Logic_Layer Logic_Layer -- \"Provides decision engine for\" --> Collection_Ops Action_Layer -- \"(dotmap) provides primitives for\" --> Relate_Branch end","title":"The Big Picture: A Unified Architecture"},{"location":"ecosystem/","text":"The dot Ecosystem: A Tour The dot ecosystem is a suite of small, focused Python libraries for manipulating nested data structures. Each tool follows the Unix philosophy: it does one thing and does it well. They are designed to be composed together, often in a pipeline, to perform complex data transformations in a clear and predictable way. This document provides an overview of each tool, its core philosophy, and its primary use case. The Two Pillars: Addressing and Logic The ecosystem is divided into two pillars, each answering a different fundamental question. 1. The Addressing Pillar: \"What is the data?\" These tools are used to find and retrieve data from your nested structures. They are organized in layers of increasing power, following the \"Principle of Least Power.\" dotget : The simplest tool. Gets a value from a single, exact path. dotstar : Adds wildcard matching ( * ) to find all items that match a structural pattern. dotselect : The most powerful user-facing selector. Adds deep searches ( ** ) and attribute-based filtering ( [key=value] ). dotpath : The underlying, extensible engine that powers dotselect and dotquery . 2. The Logic Pillar: \"Is this statement true?\" These tools are used to ask questions about your data. They don't return the data itself, but rather a boolean result ( True / False ) or an exit code ( 0 / 1 ). dotexists : The simplest logical check. Determines if a single, exact path exists. dotquery : A powerful logic engine that evaluates complex, chainable queries against your data. The Tools: A Detailed Look dotget : Simple, Exact Addressing Pillar: Addressing What it does: Gets a single value from a nested data structure using a precise, dot-separated path. Philosophy: Do one thing well. dotget is intentionally simple, has no dependencies, and its core logic is a single, small function. You are encouraged to \"steal this code\" to avoid adding a dependency for such a simple task. When to use it: When you know the exact path to the data you need, like reading from a config file or a stable API response. from dotget import get data = {\"users\": [{\"name\": \"Alice\"}]} get(data, \"users.0.name\") # => 'Alice' dotstar : Simple Wildcard Addressing Pillar: Addressing What it does: Finds all values in a data structure that match a pattern containing wildcards ( * ). Philosophy: Simple, dependency-free pattern matching. The * wildcard matches all items in a list or all values in a dictionary. Like dotget , it is simple enough to be \"stolen.\" When to use it: When you need to extract all data that conforms to a certain structure, like getting all names from a list of user objects. from dotstar import search data = {\"users\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]} search(data, \"users.*.name\") # => ['Alice', 'Bob'] dotselect : Advanced Selection Pillar: Addressing What it does: The primary user-facing tool for complex queries. It extends the simple wildcard syntax of dotstar with descendant selectors ( ** ) and predicate filters ( [key=value] ). Philosophy: Provide a powerful and expressive syntax for the 90% of complex queries, built on the dotpath engine. When to use it: When you need to find data based on its value, without knowing its exact location. It is the go-to tool for most advanced data selection tasks. from dotselect import find_first data = {\"spec\": {\"components\": [{\"type\": \"server\", \"ports\": [80, 443]}]}} # Find the ports of the 'server' component, wherever it is. find_first(data, \"**[type=server].ports\") # => [80, 443] dotpath : The Master Addressing Engine Pillar: Addressing (Engine) What it does: dotpath is the foundational extensible addressing library for the ecosystem. It provides the engine for parsing and evaluating the complex paths used by dotselect and dotquery . Philosophy: An addressing engine should be an extensible machine. It is the \"Lambda of Paths\": it allows the path language itself to be extended for specialized use cases. When to use it: You will typically use dotpath indirectly. You would interact with it directly only if you need to create your own custom pathing logic or extend the path language with new capabilities. dotexists : Simple Existence Check Pillar: Logic What it does: Checks for the existence of a value at a precise path. Philosophy: The logical counterpart to dotget . It provides the simplest possible truth check: \"Is it there?\" When to use it: To verify that a required key is present in configuration or to guard a dotget call in a script. from dotexists import check data = {\"user\": {\"name\": \"Alice\", \"address\": None}} check(data, \"user.name\") # => True check(data, \"user.age\") # => False dotquery : The Logic Engine Pillar: Logic What it does: Asks complex, compositional questions about your data and returns a boolean result. Philosophy: Logic is the anatomy of thought. dotquery separates asking a question from retrieving data. It is for validation and conditional logic, not data extraction. When to use it: When you need to validate a document against a set of rules or make decisions in a script based on the content of your data. # In the shell, check if any user is an admin $ cat users.json | dotquery \"any equals role admin\" $ echo $? # => 0 (True) The Transformation Tools Building on the addressing and logic pillars, the transformation tools help you modify, process, and reshape your data. Tool Core Function Philosophy dotmod Perform immutable modifications to data Predictable state change dotbatch Apply a sequence of modifications atomically Transactions for data dotpipe Transform data into a new shape Data transformation as a pipeline dotrelate Perform relational algebra on collections of data Bringing database concepts to JSON","title":"The dot Ecosystem: A Tour"},{"location":"ecosystem/#the-dot-ecosystem-a-tour","text":"The dot ecosystem is a suite of small, focused Python libraries for manipulating nested data structures. Each tool follows the Unix philosophy: it does one thing and does it well. They are designed to be composed together, often in a pipeline, to perform complex data transformations in a clear and predictable way. This document provides an overview of each tool, its core philosophy, and its primary use case.","title":"The dot Ecosystem: A Tour"},{"location":"ecosystem/#the-two-pillars-addressing-and-logic","text":"The ecosystem is divided into two pillars, each answering a different fundamental question.","title":"The Two Pillars: Addressing and Logic"},{"location":"ecosystem/#1-the-addressing-pillar-what-is-the-data","text":"These tools are used to find and retrieve data from your nested structures. They are organized in layers of increasing power, following the \"Principle of Least Power.\" dotget : The simplest tool. Gets a value from a single, exact path. dotstar : Adds wildcard matching ( * ) to find all items that match a structural pattern. dotselect : The most powerful user-facing selector. Adds deep searches ( ** ) and attribute-based filtering ( [key=value] ). dotpath : The underlying, extensible engine that powers dotselect and dotquery .","title":"1. The Addressing Pillar: \"What is the data?\""},{"location":"ecosystem/#2-the-logic-pillar-is-this-statement-true","text":"These tools are used to ask questions about your data. They don't return the data itself, but rather a boolean result ( True / False ) or an exit code ( 0 / 1 ). dotexists : The simplest logical check. Determines if a single, exact path exists. dotquery : A powerful logic engine that evaluates complex, chainable queries against your data.","title":"2. The Logic Pillar: \"Is this statement true?\""},{"location":"ecosystem/#the-tools-a-detailed-look","text":"","title":"The Tools: A Detailed Look"},{"location":"ecosystem/#dotget-simple-exact-addressing","text":"Pillar: Addressing What it does: Gets a single value from a nested data structure using a precise, dot-separated path. Philosophy: Do one thing well. dotget is intentionally simple, has no dependencies, and its core logic is a single, small function. You are encouraged to \"steal this code\" to avoid adding a dependency for such a simple task. When to use it: When you know the exact path to the data you need, like reading from a config file or a stable API response. from dotget import get data = {\"users\": [{\"name\": \"Alice\"}]} get(data, \"users.0.name\") # => 'Alice'","title":"dotget: Simple, Exact Addressing"},{"location":"ecosystem/#dotstar-simple-wildcard-addressing","text":"Pillar: Addressing What it does: Finds all values in a data structure that match a pattern containing wildcards ( * ). Philosophy: Simple, dependency-free pattern matching. The * wildcard matches all items in a list or all values in a dictionary. Like dotget , it is simple enough to be \"stolen.\" When to use it: When you need to extract all data that conforms to a certain structure, like getting all names from a list of user objects. from dotstar import search data = {\"users\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]} search(data, \"users.*.name\") # => ['Alice', 'Bob']","title":"dotstar: Simple Wildcard Addressing"},{"location":"ecosystem/#dotselect-advanced-selection","text":"Pillar: Addressing What it does: The primary user-facing tool for complex queries. It extends the simple wildcard syntax of dotstar with descendant selectors ( ** ) and predicate filters ( [key=value] ). Philosophy: Provide a powerful and expressive syntax for the 90% of complex queries, built on the dotpath engine. When to use it: When you need to find data based on its value, without knowing its exact location. It is the go-to tool for most advanced data selection tasks. from dotselect import find_first data = {\"spec\": {\"components\": [{\"type\": \"server\", \"ports\": [80, 443]}]}} # Find the ports of the 'server' component, wherever it is. find_first(data, \"**[type=server].ports\") # => [80, 443]","title":"dotselect: Advanced Selection"},{"location":"ecosystem/#dotpath-the-master-addressing-engine","text":"Pillar: Addressing (Engine) What it does: dotpath is the foundational extensible addressing library for the ecosystem. It provides the engine for parsing and evaluating the complex paths used by dotselect and dotquery . Philosophy: An addressing engine should be an extensible machine. It is the \"Lambda of Paths\": it allows the path language itself to be extended for specialized use cases. When to use it: You will typically use dotpath indirectly. You would interact with it directly only if you need to create your own custom pathing logic or extend the path language with new capabilities.","title":"dotpath: The Master Addressing Engine"},{"location":"ecosystem/#dotexists-simple-existence-check","text":"Pillar: Logic What it does: Checks for the existence of a value at a precise path. Philosophy: The logical counterpart to dotget . It provides the simplest possible truth check: \"Is it there?\" When to use it: To verify that a required key is present in configuration or to guard a dotget call in a script. from dotexists import check data = {\"user\": {\"name\": \"Alice\", \"address\": None}} check(data, \"user.name\") # => True check(data, \"user.age\") # => False","title":"dotexists: Simple Existence Check"},{"location":"ecosystem/#dotquery-the-logic-engine","text":"Pillar: Logic What it does: Asks complex, compositional questions about your data and returns a boolean result. Philosophy: Logic is the anatomy of thought. dotquery separates asking a question from retrieving data. It is for validation and conditional logic, not data extraction. When to use it: When you need to validate a document against a set of rules or make decisions in a script based on the content of your data. # In the shell, check if any user is an admin $ cat users.json | dotquery \"any equals role admin\" $ echo $? # => 0 (True)","title":"dotquery: The Logic Engine"},{"location":"ecosystem/#the-transformation-tools","text":"Building on the addressing and logic pillars, the transformation tools help you modify, process, and reshape your data. Tool Core Function Philosophy dotmod Perform immutable modifications to data Predictable state change dotbatch Apply a sequence of modifications atomically Transactions for data dotpipe Transform data into a new shape Data transformation as a pipeline dotrelate Perform relational algebra on collections of data Bringing database concepts to JSON","title":"The Transformation Tools"},{"location":"getting-started/","text":"Getting Started This guide will walk you through the installation and basic usage of the dot tools.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through the installation and basic usage of the dot tools.","title":"Getting Started"},{"location":"philosophy/","text":"The Philosophy of the Dot Universe It always starts with a simple problem. You have a nested dictionary or a JSON payload, and you need to get a value buried deep inside. You write data['user']['contacts'][0]['email'] and you pray that no key or index is missing along the way, lest your program crash. This leads to brittle, defensive code. The first, obvious solution is a helper function. This is where our story begins. What started as a single, humble function, dotget , evolved through a series of questions and insights into a complete, coherent, and powerful ecosystem for manipulating data structures. This is the story of that evolution\u2014a journey in API design guided by the principles of purity, pedagogy, and the principle of least power. Part I: The Single Document - The Axis of \"Depth\" Mastering operations inside a single, complex document is the foundation of the entire ecosystem. We discovered that this \"per-document intelligence\" rests on two fundamental axes: Addressing (finding data) and Action (changing data). The Addressing Layer ( dotpath ) This is the bedrock. It answers the question: \"WHAT is the value at a given location?\" The entire addressing layer is consolidated into a single, powerful, and extensible engine: dotpath . It is not just a tool, but a simple, extensible machine. Its intelligence lives within small, self-contained, \"expert\" components ( PathSegment classes) that can be added, removed, or replaced. dotpath provides a rich, JSONPath-inspired syntax with features like: - Exact selectors : users.0.name - Wildcards : users.*.name - Slices : users[0:5] - Recursive descent : **.name - Filters/Predicates : books[?(@.price < 10)] - Extensibility : The engine can be taught new syntax, like fuzzy key matching, by registering new segment parsers. All other tools in the ecosystem that need to find data ( dotquery , dotmod , etc.) use dotpath as their internal engine. The Action Layer (Manipulation) This pillar answers the question: \"HOW should this document be changed?\" It uses the Addressing Layer ( dotpath ) to find where to act. It is built on the principle of immutability\u2014always returning a modified copy. dotmod : Provides the verbs for direct, single modifications ( set , delete ). dotbatch : Provides the transactional capability to apply a sequence of dotmod changes atomically. dotpipe : Transforms a document's structure, reshaping it into something new (e.g., creating a simplified \"view model\"). Part II: Collections of Documents - The Axis of \"Breadth\" With a complete toolkit for single documents, we can now operate on collections, often represented as a stream of documents like in a JSONL file. dotquery : A Logic Engine for Collections dotquery filters a collection. It answers the question: \"Which documents in this collection match a set of logical rules?\" Its power comes from using dotpath to extract values and then applying logical conditions to them. It features a lazy, chainable QuerySet API that allows for building complex queries efficiently from the command line. # Find all books that are either cheap (under 10) or written by \"Tolkien\", # and are in stock, then resolve the query to print the matching books. $ dotquery query \"(less price 10 or equals author 'Tolkien')\" books.json \\ | dotquery and \"equals in_stock true\" \\ | dotquery resolve dotrelate : A Relational Algebra for Collections While dotquery filters a collection, dotrelate transforms and combines multiple collections. It answers: \"How can these distinct collections be joined to create new, enriched data?\" The core operation is the join , which combines documents from two collections based on a shared key. It also supports other relational operations like union , diff , and project . # Enrich user data with their orders via a left join $ dotrelate join --left-on=\"id\" --right-on=\"user_id\" --how=\"left\" users.jsonl orders.jsonl The Big Picture: A Unified Architecture This journey reveals a coherent universe of tools, underpinned by a dual API (programmatic for developers, declarative CLI for users) and a philosophy of clean, single-purpose components. graph TD subgraph The_Dot_Universe [\"The Dot Notation Universe\"] subgraph Single_Doc [\"Part I: Per-Document Intelligence ('Depth')\"] direction TB subgraph Addressing_Layer [\"Addressing Layer\"] dotpath(\"dotpath<br>(The Extensible Path Engine)\") end subgraph Action_Layer [\"Action Layer\"] dotmod(\"dotmod / dotbatch<br>(Mutation)\") --> dotpipe(\"dotpipe<br>(Transformation)\") end end subgraph Collection_Ops [\"Part II: Collection Operations ('Breadth')\"] direction TB subgraph Filter_Branch [\"Filtering / Logic\"] dotquery(\"dotquery\") end subgraph Relate_Branch [\"Relating / Combining\"] dotrelate(\"dotrelate\") end end dotpath -- \"Provides paths for\" --> Action_Layer dotpath -- \"Provides paths for\" --> Filter_Branch Filter_Branch -- \"Filters collections for\" --> Relate_Branch end","title":"The Philosophy of the Dot Universe"},{"location":"philosophy/#the-philosophy-of-the-dot-universe","text":"It always starts with a simple problem. You have a nested dictionary or a JSON payload, and you need to get a value buried deep inside. You write data['user']['contacts'][0]['email'] and you pray that no key or index is missing along the way, lest your program crash. This leads to brittle, defensive code. The first, obvious solution is a helper function. This is where our story begins. What started as a single, humble function, dotget , evolved through a series of questions and insights into a complete, coherent, and powerful ecosystem for manipulating data structures. This is the story of that evolution\u2014a journey in API design guided by the principles of purity, pedagogy, and the principle of least power.","title":"The Philosophy of the Dot Universe"},{"location":"philosophy/#part-i-the-single-document-the-axis-of-depth","text":"Mastering operations inside a single, complex document is the foundation of the entire ecosystem. We discovered that this \"per-document intelligence\" rests on two fundamental axes: Addressing (finding data) and Action (changing data).","title":"Part I: The Single Document - The Axis of \"Depth\""},{"location":"philosophy/#the-addressing-layer-dotpath","text":"This is the bedrock. It answers the question: \"WHAT is the value at a given location?\" The entire addressing layer is consolidated into a single, powerful, and extensible engine: dotpath . It is not just a tool, but a simple, extensible machine. Its intelligence lives within small, self-contained, \"expert\" components ( PathSegment classes) that can be added, removed, or replaced. dotpath provides a rich, JSONPath-inspired syntax with features like: - Exact selectors : users.0.name - Wildcards : users.*.name - Slices : users[0:5] - Recursive descent : **.name - Filters/Predicates : books[?(@.price < 10)] - Extensibility : The engine can be taught new syntax, like fuzzy key matching, by registering new segment parsers. All other tools in the ecosystem that need to find data ( dotquery , dotmod , etc.) use dotpath as their internal engine.","title":"The Addressing Layer (dotpath)"},{"location":"philosophy/#the-action-layer-manipulation","text":"This pillar answers the question: \"HOW should this document be changed?\" It uses the Addressing Layer ( dotpath ) to find where to act. It is built on the principle of immutability\u2014always returning a modified copy. dotmod : Provides the verbs for direct, single modifications ( set , delete ). dotbatch : Provides the transactional capability to apply a sequence of dotmod changes atomically. dotpipe : Transforms a document's structure, reshaping it into something new (e.g., creating a simplified \"view model\").","title":"The Action Layer (Manipulation)"},{"location":"philosophy/#part-ii-collections-of-documents-the-axis-of-breadth","text":"With a complete toolkit for single documents, we can now operate on collections, often represented as a stream of documents like in a JSONL file.","title":"Part II: Collections of Documents - The Axis of \"Breadth\""},{"location":"philosophy/#dotquery-a-logic-engine-for-collections","text":"dotquery filters a collection. It answers the question: \"Which documents in this collection match a set of logical rules?\" Its power comes from using dotpath to extract values and then applying logical conditions to them. It features a lazy, chainable QuerySet API that allows for building complex queries efficiently from the command line. # Find all books that are either cheap (under 10) or written by \"Tolkien\", # and are in stock, then resolve the query to print the matching books. $ dotquery query \"(less price 10 or equals author 'Tolkien')\" books.json \\ | dotquery and \"equals in_stock true\" \\ | dotquery resolve","title":"dotquery: A Logic Engine for Collections"},{"location":"philosophy/#dotrelate-a-relational-algebra-for-collections","text":"While dotquery filters a collection, dotrelate transforms and combines multiple collections. It answers: \"How can these distinct collections be joined to create new, enriched data?\" The core operation is the join , which combines documents from two collections based on a shared key. It also supports other relational operations like union , diff , and project . # Enrich user data with their orders via a left join $ dotrelate join --left-on=\"id\" --right-on=\"user_id\" --how=\"left\" users.jsonl orders.jsonl","title":"dotrelate: A Relational Algebra for Collections"},{"location":"philosophy/#the-big-picture-a-unified-architecture","text":"This journey reveals a coherent universe of tools, underpinned by a dual API (programmatic for developers, declarative CLI for users) and a philosophy of clean, single-purpose components. graph TD subgraph The_Dot_Universe [\"The Dot Notation Universe\"] subgraph Single_Doc [\"Part I: Per-Document Intelligence ('Depth')\"] direction TB subgraph Addressing_Layer [\"Addressing Layer\"] dotpath(\"dotpath<br>(The Extensible Path Engine)\") end subgraph Action_Layer [\"Action Layer\"] dotmod(\"dotmod / dotbatch<br>(Mutation)\") --> dotpipe(\"dotpipe<br>(Transformation)\") end end subgraph Collection_Ops [\"Part II: Collection Operations ('Breadth')\"] direction TB subgraph Filter_Branch [\"Filtering / Logic\"] dotquery(\"dotquery\") end subgraph Relate_Branch [\"Relating / Combining\"] dotrelate(\"dotrelate\") end end dotpath -- \"Provides paths for\" --> Action_Layer dotpath -- \"Provides paths for\" --> Filter_Branch Filter_Branch -- \"Filters collections for\" --> Relate_Branch end","title":"The Big Picture: A Unified Architecture"},{"location":"proposal-collections-pillar/","text":"Proposal: The Three Pillars of the dot Ecosystem This document proposes a formal, three-pillar structure for the dot ecosystem. This model clarifies the purpose of each tool, establishes a clear pedagogical progression for users, and provides a robust framework for future development. The Core Idea: Depth, Truth, and Breadth The dot ecosystem is organized into three distinct pillars, each answering a fundamental question about data: The Addressing Pillar (Depth): Answers \"Where is the data?\" within a single document . The Logic Pillar (Truth): Answers \"Is this true?\" about a single document . The Collections Pillar (Breadth): Operates on a collection of documents to answer \"Which documents?\" or \"What is the new collection?\" . The Ecosystem Diagram This diagram provides a high-level overview of the entire ecosystem, showing the tools within each pillar and their progression from simple to powerful. +-------------------------+ | The `dot` Ecosystem | +-------------------------+ | +----------------------------+----------------------------+ | | | +-----------v-----------+ +-----------v-----------+ +-----------v-----------+ | Pillar 1: Addressing | | Pillar 2: Logic | | Pillar 3: Transform | | (Depth) | | (Truth) | | (Shape) | | \"Where is the data?\" | | \"Is this true?\" | | \"How does it change?\" | +-----------------------+ +-----------------------+ +-----------------------+ | | | Simple: `dotget` `dotexists` `dotpluck` (doc\u2192any) | | | Patterns: `dotstar` `dotequals` +-------------------+ | | | | Advanced: `dotselect` `dotany`/`dotall` `dotmod` (doc\u2192doc) `dotpipe` (doc\u2192any) | | | | Engine: `dotpath` `dotquery` `dotbatch` (batch/txn) Pillar 1: The Addressing Pillar (Depth) This pillar focuses on finding and extracting data from within a single document. dotget (Simple): The entry point. Extracts a value from a single, exact path. dotstar (Patterns): Introduces wildcards ( * ) to find multiple values. dotselect (Advanced): The workhorse. Uses the full dotpath engine to perform complex selections with filters, slices, and descendants. dotpath (Engine): The underlying path-parsing and resolution engine that is extensible and compositional, allowing for custom path segments and logic. The simpler operations ( dotget , dotstar , dotselect ) should not be built on top of dotpath , but implemented as simply as possible to avoid unnecessary complexity. However, conceptually, dotpath is the \"Turing-complete\" addressing engine of the ecosystem, allowing for arbitrary path expressions and logic. Pillar 2: The Logic Pillar (Truth) This pillar focuses on asking true/false questions about a single document. dotexists (Simple Structure): The simplest question: does a path exist at all? dotequals (Simple Content): If a path exists, does it have a particular value? dotany / dotall (Quantifiers): The bridge to complexity. Applies a simple condition to multiple values found by a dotstar path. dotquery (Engine): The complete logic engine. Allows for building complex, compositional queries with AND/OR/NOT logic. Pillar 3: The Transformation Pillar (Shape) This pillar focuses on transforming the shape of a single document, answering \"How does it change?\" . All operations are immutable and compositional. dotpluck (Simple): Extracts zero or more values from a document. If the path is exact, returns a single value or none; if the path includes wildcards, returns a list of all matches. dotmod (Surgical): Performs a targeted, immutable modification to a document (e.g., set, delete, or update a value at a path). Designed for simple, direct edits\u2014easy for common cases, but limited in scope. dotpipe (Compositional): Composes multiple transformations, allowing for arbitrary mapping, restructuring, and function composition over a document. More general and powerful, but sometimes less ergonomic for simple edits than dotmod . All transformations can be piped, but dotmod and dotpipe are side-by-side: each is best for different user needs. dotbatch (Transactional): Applies a batch of modifications as a single transaction, enabling all-or-nothing guarantees and complex, multi-step updates. dotbatch can leverage both dotmod and dotpipe operations, and may support advanced features like rollback, validation, or atomicity. Collections: Lifting the Pillars to Streams The Collections layer extends the three pillars from single documents to streams or sets of documents (e.g., JSONL). It is divided into two wings: +-----------------------------+ | Collections (Breadth) | +-----------------------------+ | +-------+--------+ | | Boolean Wing Transforming Wing (Filtering) (Mapping/Relating) | | | | v v `dothas` (dotmod, dotpipe, dotbatch, dotpluck, ...) `dotfind` | `dotfilter` | | `dotrelate` (multi-collection, highest abstraction) The Boolean Wing is essential for collections: filtering, searching, and logical operations over sets of documents. Boolean algebra on collections is homomorphic to boolean logic on queries: e.g., the intersection of subsets x\u2081 and x\u2082 (from queries q\u2081 and q\u2082) is the same as applying (q\u2081 AND q\u2082) to the original collection. The Transforming Wing includes repeated application of single-document transforms (dotmod, dotpipe, dotbatch, dotpluck, etc.), but the highest-level operation is dotrelate , which operates over multiple collections and enables relational algebra (joins, unions, etc.). dotpipe in collections is analogous to a \"docview\"\u2014a new way of viewing or mapping your documents, but true database-style views and set operations are the domain of dotrelate . dotbatch at the collection level enables transactional or efficient batch operations across the entire set. Summary Table Pillar Single Document (Depth/Truth/Shape) Collections (Breadth) Addressing dotget, dotstar, dotselect, dotpath dotfind, dothas Logic dotequals, dotexists, dotany, dotall, dotquery dotfilter Transform dotpluck, dotmod, dotpipe, dotbatch dotpluck, dotmod, dotpipe, dotbatch, dotrelate Design Principles Compositionality: All operations can be composed, both within and across pillars. Immutability: All transformations are immutable; original data is never mutated. Pedagogical Progression: Each pillar and wing is organized from simple to advanced, making the ecosystem approachable for beginners and powerful for experts. Lifting: The collections layer is a lifting of the single-document pillars to operate over streams/sets, preserving the same semantics and compositionality. By adopting this formal structure, the dot ecosystem provides a highly consistent, predictable, and teachable set of tools for both single-document and collection-oriented data manipulation.","title":"Proposal: The Three Pillars of the dot Ecosystem"},{"location":"proposal-collections-pillar/#proposal-the-three-pillars-of-the-dot-ecosystem","text":"This document proposes a formal, three-pillar structure for the dot ecosystem. This model clarifies the purpose of each tool, establishes a clear pedagogical progression for users, and provides a robust framework for future development.","title":"Proposal: The Three Pillars of the dot Ecosystem"},{"location":"proposal-collections-pillar/#the-core-idea-depth-truth-and-breadth","text":"The dot ecosystem is organized into three distinct pillars, each answering a fundamental question about data: The Addressing Pillar (Depth): Answers \"Where is the data?\" within a single document . The Logic Pillar (Truth): Answers \"Is this true?\" about a single document . The Collections Pillar (Breadth): Operates on a collection of documents to answer \"Which documents?\" or \"What is the new collection?\" .","title":"The Core Idea: Depth, Truth, and Breadth"},{"location":"proposal-collections-pillar/#the-ecosystem-diagram","text":"This diagram provides a high-level overview of the entire ecosystem, showing the tools within each pillar and their progression from simple to powerful. +-------------------------+ | The `dot` Ecosystem | +-------------------------+ | +----------------------------+----------------------------+ | | | +-----------v-----------+ +-----------v-----------+ +-----------v-----------+ | Pillar 1: Addressing | | Pillar 2: Logic | | Pillar 3: Transform | | (Depth) | | (Truth) | | (Shape) | | \"Where is the data?\" | | \"Is this true?\" | | \"How does it change?\" | +-----------------------+ +-----------------------+ +-----------------------+ | | | Simple: `dotget` `dotexists` `dotpluck` (doc\u2192any) | | | Patterns: `dotstar` `dotequals` +-------------------+ | | | | Advanced: `dotselect` `dotany`/`dotall` `dotmod` (doc\u2192doc) `dotpipe` (doc\u2192any) | | | | Engine: `dotpath` `dotquery` `dotbatch` (batch/txn)","title":"The Ecosystem Diagram"},{"location":"proposal-collections-pillar/#pillar-1-the-addressing-pillar-depth","text":"This pillar focuses on finding and extracting data from within a single document. dotget (Simple): The entry point. Extracts a value from a single, exact path. dotstar (Patterns): Introduces wildcards ( * ) to find multiple values. dotselect (Advanced): The workhorse. Uses the full dotpath engine to perform complex selections with filters, slices, and descendants. dotpath (Engine): The underlying path-parsing and resolution engine that is extensible and compositional, allowing for custom path segments and logic. The simpler operations ( dotget , dotstar , dotselect ) should not be built on top of dotpath , but implemented as simply as possible to avoid unnecessary complexity. However, conceptually, dotpath is the \"Turing-complete\" addressing engine of the ecosystem, allowing for arbitrary path expressions and logic.","title":"Pillar 1: The Addressing Pillar (Depth)"},{"location":"proposal-collections-pillar/#pillar-2-the-logic-pillar-truth","text":"This pillar focuses on asking true/false questions about a single document. dotexists (Simple Structure): The simplest question: does a path exist at all? dotequals (Simple Content): If a path exists, does it have a particular value? dotany / dotall (Quantifiers): The bridge to complexity. Applies a simple condition to multiple values found by a dotstar path. dotquery (Engine): The complete logic engine. Allows for building complex, compositional queries with AND/OR/NOT logic.","title":"Pillar 2: The Logic Pillar (Truth)"},{"location":"proposal-collections-pillar/#pillar-3-the-transformation-pillar-shape","text":"This pillar focuses on transforming the shape of a single document, answering \"How does it change?\" . All operations are immutable and compositional. dotpluck (Simple): Extracts zero or more values from a document. If the path is exact, returns a single value or none; if the path includes wildcards, returns a list of all matches. dotmod (Surgical): Performs a targeted, immutable modification to a document (e.g., set, delete, or update a value at a path). Designed for simple, direct edits\u2014easy for common cases, but limited in scope. dotpipe (Compositional): Composes multiple transformations, allowing for arbitrary mapping, restructuring, and function composition over a document. More general and powerful, but sometimes less ergonomic for simple edits than dotmod . All transformations can be piped, but dotmod and dotpipe are side-by-side: each is best for different user needs. dotbatch (Transactional): Applies a batch of modifications as a single transaction, enabling all-or-nothing guarantees and complex, multi-step updates. dotbatch can leverage both dotmod and dotpipe operations, and may support advanced features like rollback, validation, or atomicity.","title":"Pillar 3: The Transformation Pillar (Shape)"},{"location":"proposal-collections-pillar/#collections-lifting-the-pillars-to-streams","text":"The Collections layer extends the three pillars from single documents to streams or sets of documents (e.g., JSONL). It is divided into two wings: +-----------------------------+ | Collections (Breadth) | +-----------------------------+ | +-------+--------+ | | Boolean Wing Transforming Wing (Filtering) (Mapping/Relating) | | | | v v `dothas` (dotmod, dotpipe, dotbatch, dotpluck, ...) `dotfind` | `dotfilter` | | `dotrelate` (multi-collection, highest abstraction) The Boolean Wing is essential for collections: filtering, searching, and logical operations over sets of documents. Boolean algebra on collections is homomorphic to boolean logic on queries: e.g., the intersection of subsets x\u2081 and x\u2082 (from queries q\u2081 and q\u2082) is the same as applying (q\u2081 AND q\u2082) to the original collection. The Transforming Wing includes repeated application of single-document transforms (dotmod, dotpipe, dotbatch, dotpluck, etc.), but the highest-level operation is dotrelate , which operates over multiple collections and enables relational algebra (joins, unions, etc.). dotpipe in collections is analogous to a \"docview\"\u2014a new way of viewing or mapping your documents, but true database-style views and set operations are the domain of dotrelate . dotbatch at the collection level enables transactional or efficient batch operations across the entire set.","title":"Collections: Lifting the Pillars to Streams"},{"location":"proposal-collections-pillar/#summary-table","text":"Pillar Single Document (Depth/Truth/Shape) Collections (Breadth) Addressing dotget, dotstar, dotselect, dotpath dotfind, dothas Logic dotequals, dotexists, dotany, dotall, dotquery dotfilter Transform dotpluck, dotmod, dotpipe, dotbatch dotpluck, dotmod, dotpipe, dotbatch, dotrelate","title":"Summary Table"},{"location":"proposal-collections-pillar/#design-principles","text":"Compositionality: All operations can be composed, both within and across pillars. Immutability: All transformations are immutable; original data is never mutated. Pedagogical Progression: Each pillar and wing is organized from simple to advanced, making the ecosystem approachable for beginners and powerful for experts. Lifting: The collections layer is a lifting of the single-document pillars to operate over streams/sets, preserving the same semantics and compositionality. By adopting this formal structure, the dot ecosystem provides a highly consistent, predictable, and teachable set of tools for both single-document and collection-oriented data manipulation.","title":"Design Principles"}]}